<!DOCTYPE html>
<html>

<head>

    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <title>es6</title>
    <script src="../js/jquery.js"></script>
    <script>
        // //promise - 许诺。
        // //生命周期
        // //pending进行中 
        // //操作完成 用 .then() 对应两种结果（fulfilled 成了 rejected 不成）

        // //回调函数传统写法：
        // function func(cb) {
        //     setTimeout(() => {
        //         cb && cb();
        //     }, 1000);
        // }
        // func(() => {
        //     console.log(1);
        //     func(() => {
        //         console.log(2);
        //         func(() => {
        //             console.log(3);
        //             func(() => {
        //                 console.log(4);
        //             });
        //         });
        //     });
        // });


        // //promise写法
        // function func2() {
        //     return new Promise((resolve, reject) => {
        //         setTimeout(() => {
        //             resolve();
        //         }, 1000);
        //     });
        // }
        // func2().then(() => {
        //     console.log(10);
        //     return func2();
        // }).then(() => {
        //     console.log(20);
        //     return func2();
        // }).then(() => {
        //     console.log(30);
        //     return func2();
        // }).then(() => {
        //     console.log(40);
        //     return func2();
        // })

        // //一个简单的promist 封装的一个ajax
        // let p = new Promise(function (resolve, reject) {
        //     //这里封装异步代码， resolve 成功了，reject失败了。
        //     $.ajax({
        //         url: "data.txt",
        //         dataType: "json",
        //         success(arr) {
        //             resolve(arr);
        //         },
        //         error(err) {
        //             reject(err);
        //         }
        //     });
        // });

        // p.then(function (arr) {
        //     console.log(arr);
        // }, (err) => {
        //     console.log(err);
        // });

        // //用promise封装所有ajax （jquery已经做了，3以上，可以看返回值是否有promise）
        // function createPromise(url) {
        //     return new Promise(function (resolve, reject) {
        //         $.ajax({
        //             url: url,
        //             dataType: 'json',
        //             success(arr) {
        //                 resolve(arr);
        //             },
        //             error(err) {
        //                 reject(err);
        //             }
        //         });
        //     });
        // }
        // Promise.all([
        //     createPromise('data/data.js'),
        //     createPromise('data/data.txt')
        // ]).then(function (arr) {
        //     let [res1, res2] = arr;
        //     console.log("全部成功了");
        //     console.log(res1);
        //     console.log(res2);
        // }, function () {
        //     console.log("至少一个失败了");
        // });
        // //jquery3对promise的封装；
        // Promise.all([
        //     $.ajax({ url: "data/data.js", dataType: "json" }),
        //     $.ajax({ url: "data/data.txt", dataType: "json" })
        // ]).then(function (results) {
        //     let [res1, res2] = results;
        //     console.log(res1, res2);
        // }, function (err) {
        //     console.log(err);
        // });
        // //promise其他方法：
        // //Promise.race()竞速模式,有拿不到的忽略
        // // Promise.race([
        // //     $.ajax({url:"data/data.js",dataType:"json"}),
        // //     $.ajax({url:"data/data.txt",dataType:"json"})
        // // ]);

        // //箭头函数
        // //如果只有一个参数，()可以省
        // //如果只有一个return, {}和return 可以省
        // //更多的还是写法上的一些变化。
        // function name1() { };
        // let name2 = () => { };
        // let add = function (a) { return a + 1; }
        // let add2 = a => a + 1;
        // //匿名函数写法 function(){}  ()=>{} ,去function加箭头，只是写法变化
        // window.onload = function (a, b) { console.log("加载" + a + b) };
        // window.onload = (a, b) => { console.log("加载" + a + b) };

        // //函数展开/拓展，默认参数
        // //参数拓展可以用来收集多余的参数，可以所有函数都加上。...args必须在最后一个。
        // let argsTest = (a, b, ...args) => { console.log(args); };
        // argsTest(1, 2, 3, 4, 5, 6, 7, 8, 9);
        // //展开数组：任何数组变量前加三个点相当于展开写
        // let arr1 = [1, 2, 3];
        // let arr2 = [4, 5, 6];
        // let arr3 = [...arr1, ...arr2];
        // //默认参数
        // let autoarg = (a, b = 2, c = 3, ...args) => { console.log(a + b + c); };
        // autoarg(1);

        // //解构赋值
        // //1.左右两边结构必须一样。
        // //2.声明和赋值不能分开，必须一句话。
        // let [a, b, c] = [1, 2, { "a": 1, "b": 2 }];
        // console.log(c);

        // //数组的四大方法：map 映射 reduce 汇总 filter 过滤 forEach 遍历。
        // let arrData = [
        //     { "id": 1, "name": "张三", "score": 100 },
        //     { "id": 1, "name": "张三", "score": 10 },
        //     { "id": 1, "name": "张三", "score": 50 },
        //     { "id": 1, "name": "张三", "score": 70 },
        //     { "id": 1, "name": "张三", "score": 16 },
        // ];
        // //map映射，输入多少，输出多少。
        // let result = arrData.map(item => item.score > 60 ? "及格" : "不及格");
        // console.log(result);
        // //reduce，输入不限，输出一个。
        // // result = arrData.reduce((temp,item,index)=>{
        // //     index == arrData.length ? (temp.score + item.score)/2 : temp + item.score;
        // //     return temp.score;
        // // });
        // // console.log(result);
        // //filter过滤器，把满足某条件的过滤出来
        // result = arrData.filter(item => item.score > 60);
        // console.log(result);
        // //forEach 等同于for遍历
        // arrData.forEach((item, index) => {
        //     console.log(index + ": " + item);
        // })

        // //字符串 新增两个方法（startWith endsWith），和模板系统
        // let str1 = "http://baidu.com";    // "百度的网址是："+str1+"这个地址";
        // //字符串模板：反单引号，1的左边,可以随意折行
        // let str2 = `百度的网址是：${str1} 这个地址`;
        // console.log(str2);

        // //对象
        // //es5写法： 
        // function UserES5(name, pass) {
        //     this.name = name;
        //     this.pass = pass;
        // }
        // UserES5.prototype.show = function () {
        //     console.log(this.name, this.pass);
        // }
        // var user1 = new UserES5("张三", "12345");
        // user1.show();
        // //es5继承：
        // function vipUserES5(name, pass, viplevel) {
        //     UserES5.call(this, name, pass);
        //     this.level = viplevel;
        // }
        // vipUserES5.prototype = new UserES5();
        // vipUserES5.prototype.constructor = vipUserES5;
        // vipUserES5.prototype.showLevel = function () {
        //     console.log(this.name, this.pass, this.level);
        // }
        // user3= new vipUserES5("王五","123","3");
        // user3.showLevel();
        // //以上写法：类和构造函数是一样的。 属性和方法分开写了。es6更像java了
        // //以下写法，类 构造器分开了，类内加方法。
        // class UserES6 {
        //     constructor(name, pass) {
        //         this.name = name;
        //         this.pass = pass;
        //     }
        //     show() {
        //         console.log(this.name, this.pass);
        //     }
        // }
        // let user2 = new UserES6("李四", "12345");
        // user2.show();
        // //继承：es6新增 extends 关键字 super（父类/超类）
        // class VipUserES6 extends UserES6 {
        //     constructor(name, pass, level) {
        //         super(name, pass);
        //         this.level = level;
        //     }
        //     showLevel() {
        //         console.log(this.name, this.pass, this.level);
        //     }
        // }
        // let user4 = new VipUserES6("赵六", "12345","4");
        // user4.showLevel();
        //ES6面向对象的应用：以react为例：
        // class Test extends React.Component {
        //     constructor(...args){
        //         super(...args);
        //     }
        //     render() {return .......}
        // }

        //es6 json 一些特性：
        //名字和值一样时可以省略：a = 1;{a:a,b:2} 同 {a,b:2}
        //方法 可以省：function {c:"1",show:function(){}} 同 {c:"1",show(){}}
        
        //generator 构造器 可以暂停的函数
        //generator 是一种函数，特征是有个*,每遇到一个yield，需要next才往下走
        let testAjax = function *(){
            let a = yield setTimeout(function *ee(){
                a = 110;
                return 110
            },500);
            console.log('aaaaabb  ' + a);
            yield;
            let b= a + 3; 
            console.log(b);
        }
        let t1 = testAjax();
        t1.next();
            t1.next();
            t1.next();
        //t1.next();
    </script>

<body>
</body>

</html>